B. Bernard
CS455 Systems Programming
Final Project: LibC Cryptographic Functions

Intro:
	To ensure the safety and security of data, functions were created and added to the GNU library to encrypt data so that it can be stored and sent safely. One way to ensure security is for users to use passwords to protect data. Since passwords are usually short and easy to crack, passphrases are used since they are longer and more complex. Passphrases are not used or stored in their plaintext form as that would compromise the integrity of the security. Hash functions are used to encrypt passphrases for the purpose of securely storing and using passwords. Some programs also need randomly generated bytes of data to use as keys or as hash data to confuse and deter hackers. For this purpose the GNU library has a function that can be used to create these randomly generated unpredictable bytes of any size to be used. These are created using a randomly generated encryption key and a ‘salt’ or one way function string. 
PassPhrase Storage:
A system should be protected in multiple ways to ensure the security of data. A traditional way to do this is to use passwords to restrict access to unauthorized users. A password is a word or phrase used to grant access to something. In order to ensure security of the password the phrase is not stored or entered in plaintext, however it is encrypted once entered by the user and the system will accept only the correct encryption password. Passwords are converted into hashes using one way functions before they are used or stored. 

	One Way Hash Functions:
A one way hash function is a mathematical function that takes a string of a length of any variable and converts it into a fixed-length binary sequence. One way hashes are designed to be easy to encrypt but difficult to decrypt as well as reduce the possibility that two strings would produce the same hash sequence. LibC cryptographic functions use four different one way functions, SHA-2-512, SHA-2-256, MD5 and DES. 

SHA stands for Secure Hashing Algorithm. SHA-2-512 results in a 512-bit hash sequence and has a 1,024 block size. The input process is divided as 64-bit words, initialization variables and constants. This process also takes 80 rounds of operations before the final hash is fully encrypted. Similarly, SHA-2-256 produces a 256-bit hash and has 512-bit block size. The input is processed as 32-bit words, initialization variables and constants. This process takes 64 rounds of processing before it reaches its encrypted hash form. The larger the size of the bit sequence, the more difficult it is to decrypt the hash. The longer the hash is the more computational time it consumes to calculate the hash therefore it is harder to crack. The size of the block is important because the smaller block that the system needs to process the shorter computational time. The larger the block size is the more time and resources it takes to encrypt the hash. Length of words, initialization variables and constants are important because the block size is always sixteen times the size of the word length. For a 512-bit block size each word needs to be 32-bits long while in a 1,024-bit block size the words need to be 64-bits long 

	MD5 or message-digest algorithm is a protocol used for authenticating content and digital signatures. The hashing algorithm converts data into a string of 32 characters and a file of 1.2 GB also generates a 32 character hash.  The hash is 16 bytes, with 32 numbers and letters, it will always be a 128-bit hash. When sending the encrypted hash the computer that receives it authenticates the hash by comparing the two strings. 

DES or Data Encryption Standard encrypts data in blocks sizes of 64 bit with a key length of 56. The key is originally a 64 bit key but every 8th bit of the key is ignored to produce a 56 bit key. The encryption process includes the plaintext being encrypted once, then that encrypted text is split in half and each half goes through 16 rounds of encryption. After the 16 rounds the two halves are put together to produce the final encrypted text. 

	A salt parameter is used to decide which one-way hash function is used and ensures that the encrypted output is different for every user even if they use the same passphrase. Without this parameter an attacker could run the crypt function once and compare the result to all hashes, the salt function makes it so the attacker has to call crypt for each user and function. To verify the passphrase you pass the hashed passphrase to the salt parameter. To hash a new passphrase you set the salt parameters to a string consisting of a prefix and a sequence of random characters. Each encryption method uses its own prefix and set of random sequence characters. SHA-2-512 used the prefix of $6$ with a random sequence of 16 characters. SHA-2-256 uses a prefix of $5$ with a random sequence of 16 characters. MD5 uses a prefix of $1$ and has a random sequence of 8 characters. FInally, DES has no prefix and has a random sequence of 2 characters. 

Crypt function

	The crypt function uses memory allocation pointed to by its data argument for the processes it completes and the string it returns. It can be accessed by multiple threads as long as unique data objects are used, any time another call is made with the same data the string it returns will be overwritten. 

The crypt function is written as follows 
char * crypt (const char *phrase, const char *salt)



The function takes parameters of a plaintext phrase and a salt parameter and returns a encrypted version of the hash using one of the one way hash functions. 
Some possible errors when running this function are;
EINVAL- the salt parameter is invalid
EPERM- the system forbids the use of the hash version selected
ENOMEM- failed to allocate internal scratch storage
ENOSYS and EOPNOTSUPP- the hashing passphrases are not supported or the hash function selected by the salt parameter is not supported. 
Below are example codes for how the LibC crypt function is used  
The program below shows how to use the crypt function for the first time when a passphrase is entered to encrypt it

The program below verifies a passphrase and shows that different one way hash functions produce different hashes for the same passphrase.


 Generating Unpredictable Bytes:
	Oftentimes cryptographic applications need a set of random data that is encrypted so that evesdroppers cannot interfere with the message. Two functions can be used to achieve this, getentropy and getrandom. Getentropy writes the length of bytes of a string of random data to an array staring at a buffer variable. The length can be no longer than 256 bit. When the program runs successfully the program returns zero. If there is an error the program will return -1. Gerrandom writes a length of bytes of random data to an array starting at the buffer variable. There are flag arguments that are used to return a desired output. The three flags are Grnd_random which may call a block at any time, Grnd_nonblock which returns if there is no available data and  Grnd_insecure which writes random data that might not be cryptographically secure. Get random has a cancellation point unlike getentropy. When the function successfully runs, a number of bytes will return to the buffer, if the function fails -1 is returned. 
            
GetEntropy function is written as shown below
int getentropy(void *buffer, size_t length);

Possible errors that can be thrown by the getentropy function include 
ENOSYS- operating system does not implement randomness source
EFAULT- combination of buffer and length arguments are invalid memory range
EIO- length is longer than 256 or the kernel entropy pool has reached failure

Getrandom function is written as 
ssize_t getrandom (void *buffer, size_t length, unsigned int flags)

Possible errors that can be thrown by the getrandom function include 
ENOSYS- operating system does not implement randomness source
EAGAIN- no random data was available and Grnd_nonblock was specified as the flag
EINTR- A system call was interrupted in the process
EINVAL- the flags argument contains an invalid combination 


Sources:
https://www.gnu.org/software/libc/manual/pdf/libc.pdf
https://www.gnu.org/software/libc/manual/html_node/Unpredictable-Bytes.html
http://www.aspencrypt.com/crypto101_hash.html 
https://www.avast.com/c-md5-hashing-algorithm 
